use crate::types::TrialOrbital;
use crystal::Crystal;
use dwconsts::TWOPI;
use gvector::GVector;
use kgylm::KGYLM;
use kpts::KPTS;
use matrix::Matrix;
use pspot::PSPot;
use pwbasis::PWBasis;
use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufWriter, Write};
use types::c64;

pub(crate) fn build_trial_orbitals(
    num_wann: usize,
    crystal: &Crystal,
    pots: &PSPot,
) -> io::Result<Vec<TrialOrbital>> {
    let mut all_trial_orbitals = Vec::new();

    for (iat, species) in crystal.get_atom_species().iter().enumerate() {
        let atpsp = pots.get_psp(species);
        let l_channels = atpsp.get_wfc_channels();
        if l_channels.is_empty() {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!(
                    "no pseudo-atomic wavefunctions (PP_CHI) found for species '{}'",
                    species
                ),
            ));
        }

        for l in l_channels {
            for m in utility::get_quant_num_m(l) {
                all_trial_orbitals.push(TrialOrbital {
                    atom_index: iat,
                    species: species.clone(),
                    l,
                    m,
                });
            }
        }
    }

    if all_trial_orbitals.len() < num_wann {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            format!(
                "not enough trial orbitals from pseudo-atomic wavefunctions: requested num_wann={}, available={}",
                num_wann,
                all_trial_orbitals.len()
            ),
        ));
    }

    all_trial_orbitals.truncate(num_wann);
    Ok(all_trial_orbitals)
}

pub(crate) fn write_amn_file(
    filename: &str,
    num_bands: usize,
    crystal: &Crystal,
    kpts: &dyn KPTS,
    eigvecs: &[Matrix<c64>],
    all_pwbasis: &[PWBasis],
    gvec: &GVector,
    pots: &PSPot,
    trial_orbitals: &[TrialOrbital],
) -> io::Result<()> {
    let nkpt = eigvecs.len();
    if nkpt != all_pwbasis.len() {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "inconsistent dimensions for Wannier90 amn export",
        ));
    }

    let num_wann = trial_orbitals.len();
    if num_wann == 0 {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "trial orbital list for AMN must not be empty",
        ));
    }

    let file = File::create(filename)?;
    let mut writer = BufWriter::new(file);

    writeln!(
        writer,
        "Generated by dftworks (Bloch-trial overlaps from pseudo-atomic wavefunctions)"
    )?;
    writeln!(writer, "{:8} {:8} {:8}", num_bands, nkpt, num_wann)?;

    let lmax_trial = trial_orbitals.iter().map(|orb| orb.l).max().unwrap_or(0);
    let atom_positions = crystal.get_atom_positions();
    let miller = gvec.get_miller();

    for ik in 0..nkpt {
        if eigvecs[ik].ncol() != num_bands {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "number of bands in eigenvectors does not match control.nband",
            ));
        }

        let pwwfc = &all_pwbasis[ik];
        let npw = pwwfc.get_n_plane_waves();
        let kgylm = KGYLM::new(pwwfc.get_k_cart(), lmax_trial, gvec, pwwfc);
        let k_frac = kpts.get_k_frac(ik);

        let mut atom_structure_factors = Vec::with_capacity(atom_positions.len());
        for atom_pos in atom_positions.iter() {
            let mut sfact = fhkl::compute_structure_factor_for_many_g_one_atom(
                miller,
                pwwfc.get_gindex(),
                *atom_pos,
            );

            let k_dot_tau = k_frac.x * atom_pos.x + k_frac.y * atom_pos.y + k_frac.z * atom_pos.z;
            let k_phase = c64::new(0.0, -TWOPI * k_dot_tau).exp();
            for s in sfact.iter_mut() {
                *s *= k_phase;
            }

            atom_structure_factors.push(sfact);
        }

        let mut radial_lookup = HashMap::new();
        for orb in trial_orbitals.iter() {
            let key = (orb.species.clone(), orb.l);
            if radial_lookup.contains_key(&key) {
                continue;
            }

            let atpsp = pots.get_psp(&orb.species);
            if !atpsp.has_wfc(orb.l) {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidInput,
                    format!(
                        "missing pseudo-atomic wavefunction for species '{}' and l={}",
                        orb.species, orb.l
                    ),
                ));
            }

            let chi = atpsp.get_wfc(orb.l);
            let chi_kg = compute_atomic_wfc_of_kg(
                pwwfc.get_kg(),
                orb.l,
                chi,
                atpsp.get_rad(),
                atpsp.get_rab(),
                crystal.get_latt().volume(),
            )?;
            radial_lookup.insert(key, chi_kg);
        }

        for (n, orb) in trial_orbitals.iter().enumerate() {
            let ylm = kgylm.get_data(orb.l, orb.m);
            let chi_kg = radial_lookup
                .get(&(orb.species.clone(), orb.l))
                .ok_or_else(|| {
                    io::Error::new(
                        io::ErrorKind::InvalidData,
                        "failed to locate precomputed radial orbital in AMN export",
                    )
                })?;
            let sfact = &atom_structure_factors[orb.atom_index];

            for mband in 0..num_bands {
                let mut overlap = c64::new(0.0, 0.0);
                for ig in 0..npw {
                    let g_n = ylm[ig] * chi_kg[ig] * sfact[ig];
                    overlap += eigvecs[ik][[ig, mband]].conj() * g_n;
                }

                writeln!(
                    writer,
                    "{:5} {:5} {:5} {:18.12E} {:18.12E}",
                    mband + 1,
                    n + 1,
                    ik + 1,
                    overlap.re,
                    overlap.im
                )?;
            }
        }
    }

    writer.flush()?;
    Ok(())
}

fn compute_atomic_wfc_of_kg(
    kg: &[f64],
    l: usize,
    chi: &[f64],
    rad: &[f64],
    rab: &[f64],
    volume: f64,
) -> io::Result<Vec<f64>> {
    if chi.len() != rad.len() || rad.len() != rab.len() {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "inconsistent radial-grid dimensions while building trial orbitals",
        ));
    }

    let npw = kg.len();
    let mut chi_kg = vec![0.0; npw];
    let mut work = vec![0.0; rad.len()];
    let prefactor = dwconsts::FOURPI / volume.sqrt();

    for ig in 0..npw {
        for ir in 0..rad.len() {
            let r = rad[ir];
            work[ir] = chi[ir] * r * special::spherical_bessel_jn(l, kg[ig] * r);
        }
        chi_kg[ig] = prefactor * integral::simpson_rab(&work, rab);
    }

    Ok(chi_kg)
}
