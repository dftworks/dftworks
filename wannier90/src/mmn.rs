use crate::types::MeshTopology;
use gvector::GVector;
use matrix::Matrix;
use pwbasis::PWBasis;
use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufWriter, Write};
use types::c64;

pub(crate) fn write_mmn_file(
    filename: &str,
    num_bands: usize,
    topology: &MeshTopology,
    eigvecs: &[Matrix<c64>],
    all_pwbasis: &[PWBasis],
    gvec: &GVector,
) -> io::Result<()> {
    // MMN stores overlaps between neighboring k points:
    //   M_{mn}^{(k,b)} = <u_{m,k} | u_{n,k+b}>
    // written as one block per (k, neighbor) pair.
    let nkpt = eigvecs.len();
    if nkpt != all_pwbasis.len() || nkpt != topology.neighbors.len() {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "inconsistent dimensions for Wannier90 mmn export",
        ));
    }

    let file = File::create(filename)?;
    let mut writer = BufWriter::new(file);

    writeln!(writer, "Generated by dftworks")?;
    writeln!(writer, "{:8} {:8} {:8}", num_bands, nkpt, topology.nntot)?;

    let miller = gvec.get_miller();
    // Precompute Miller-index -> row lookup maps for each k basis to match
    // shifted G vectors efficiently when building MMN blocks.
    let mut k_lookup_maps = Vec::with_capacity(nkpt);
    for pw in all_pwbasis.iter() {
        let mut map = HashMap::with_capacity(pw.get_n_plane_waves() * 2);
        for (row, gidx) in pw.get_gindex().iter().enumerate() {
            let m = miller[*gidx];
            map.insert((m.x, m.y, m.z), row);
        }
        k_lookup_maps.push(map);
    }

    for ik in 0..nkpt {
        if eigvecs[ik].ncol() != num_bands {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "number of bands in eigenvectors does not match control.nband",
            ));
        }

        for nn in topology.neighbors[ik].iter() {
            let ikb = nn.ikb;

            writeln!(
                writer,
                "{:8} {:8} {:4} {:4} {:4}",
                ik + 1,
                ikb + 1,
                nn.gshift[0],
                nn.gshift[1],
                nn.gshift[2]
            )?;

            let block = compute_mmn_block(
                &eigvecs[ik],
                &eigvecs[ikb],
                all_pwbasis[ik].get_gindex(),
                &k_lookup_maps[ikb],
                miller,
                nn.gshift,
                num_bands,
            );

            // Wannier90 expects n outer, m inner.
            for n in 0..num_bands {
                for m in 0..num_bands {
                    let v = block[m + n * num_bands];
                    writeln!(writer, " {:18.12E} {:18.12E}", v.re, v.im)?;
                }
            }
        }
    }

    writer.flush()?;
    Ok(())
}

fn compute_mmn_block(
    c_k: &Matrix<c64>,
    c_kb: &Matrix<c64>,
    gindex_k: &[usize],
    lookup_kb: &HashMap<(i32, i32, i32), usize>,
    miller: &[vector3::Vector3i32],
    gshift: [i32; 3],
    num_bands: usize,
) -> Vec<c64> {
    // Build one num_bands x num_bands overlap block for a fixed (k, k+b).
    let mut out = vec![c64::new(0.0, 0.0); num_bands * num_bands];

    for (row_k, gidx) in gindex_k.iter().enumerate() {
        let m = miller[*gidx];
        let key = (m.x + gshift[0], m.y + gshift[1], m.z + gshift[2]);

        let Some(&row_kb) = lookup_kb.get(&key) else {
            // If shifted G not present in neighbor basis, contribution is zero.
            continue;
        };

        for ib in 0..num_bands {
            let c1_conj = c_k[[row_k, ib]].conj();
            for jb in 0..num_bands {
                // Accumulate c_k^*(G,m) * c_{k+b}(G+b,n).
                out[ib + jb * num_bands] += c1_conj * c_kb[[row_kb, jb]];
            }
        }
    }

    out
}
